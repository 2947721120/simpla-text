<link rel="import" href="../polymer/polymer.html">

<script>
  import Editor from './editor';

  window.SimplaText = window.SimplaText || {};
  window.SimplaText.Editor = Editor;
</script>

<dom-module id="simpla-text-toolbar">
  <template>
    <style>
      :host, *, *::before, *::after {
        box-sizing: border-box;
      }

      :host {
        -moz-osx-font-smoothing: grayscale;
         -webkit-font-smoothing: antialiased;
                 font-smoothing: antialiased;

        --tool-size: 25px;

        display: flex;
      }

      :host([hidden]) {
        display: none;
      }

      .tool {
        width: var(--tool-size);
        height: var(--tool-size);
        border: solid thin blue;
        flex-shrink: 0;
      }

      .tool[active] {
        border-bottom: 4px solid blue;
      }
    </style>
    <button
      class="tool"
      on-tap="_runCommand"
      active$="[[_checkToolIsActive('bold', activeTools)]]"
      data-command="bold">b</button>
    <button
      class="tool"
      on-tap="_runCommand"
      active$="[[_checkToolIsActive('italic', activeTools)]]"
      data-command="italic">i</button>
    <button
      class="tool"
      on-tap="_runCommand"
      active$="[[_checkToolIsActive('underline', activeTools)]]"
      data-command="underline">u</button>
    <button
      class="tool"
      on-tap="_toggleLinkInput">l<input id="link-input" type="text" hidden /></button>
  </template>
  <script>
    const GUTTER = 5;

    function addPadding(rect, padding) {
      return {
        top: rect.top - padding,
        right: rect.right + padding,
        bottom: rect.bottom + padding,
        left: rect.left - padding,
        width: rect.width + 2 * padding,
        height: rect.height + 2 * padding
      };
    }

    class SimplaTextToolbar extends HTMLElement {
      beforeRegister() {
        this.is = 'simpla-text-toolbar';

        this.properties = {
          tools: {
            type: Array,
            value: () => [ 'bold', 'italic', 'underline' ]
          },

          activeTools: {
            type: Array,
            value: () => []
          }
        }
      }

      filterActiveTools(isActive) {
        const byActive = ({ active }) => !!active,
              toControl = ({ name }) => name,
              getStatus = (name) => {
                return isActive(name)
                  .then(active => ({ name, active }));
              };

        return Promise.all(this.tools.map(getStatus))
          .then(status => status.filter(byActive))
          .then(status => status.map(toControl))
          .then(commands => this.activeTools = commands);
      }

      hoverOverSelection(selection) {
        let rangeBounds,
            ownBounds,
            parentOffsets,
            boundaries,
            offsetLeft,
            offsetTop;

        if (!selection) {
          return;
        }

        rangeBounds = selection.getRangeAt(0).getBoundingClientRect();
        ownBounds = this.getBoundingClientRect();
        parentOffsets = this.parentElement.getBoundingClientRect();
        boundaries = {
          top: window.scrollY,
          left: window.scrollX,
          right: window.innerWidth + window.scrollX,
          bottom: window.innerHeight + window.scrollY
        };

        parentOffsets = {
          top: parentOffsets.top + window.scrollY,
          left: parentOffsets.left + window.scrollX
        };

        ({ offsetLeft, offsetTop } = this._getOffsetsFromBounds({
          rangeBounds,
          parentOffsets,
          ownBounds,
          boundaries
        }));

        Object.assign(this.style, {
          left: `${offsetLeft}px`,
          top: `${offsetTop}px`
        });
      }

      /**
       * TODO: Read window from arg and update offsets to keep inside the window
       */
      _getOffsetsFromBounds({ rangeBounds, parentOffsets, ownBounds, boundaries, gutter = GUTTER }) {
        let { left, top } = rangeBounds,
            centerOffset = (rangeBounds.width - ownBounds.width) / 2;

        boundaries = addPadding(boundaries, -gutter);

        left += centerOffset;
        top -= ownBounds.height + gutter;

        // Fit to within boundaries
        if (left < boundaries.left) {
          left = boundaries.left;
        }

        if (top < boundaries.top) {
          top = boundaries.top;

          if (top < rangeBounds.top && top > rangeBounds.bottom || top + ownBounds.height < rangeBounds.bottom && top + ownBounds.height > rangeBounds.top) {
            top = rangeBounds.bottom + gutter;
          }
        }

        if (left + ownBounds.width > boundaries.right) {
          left = boundaries.right - ownBounds.width;
        }

        if (top + ownBounds.height > boundaries.bottom) {
          top = boundaries.bottom - ownBounds.height;
        }

        return {
          offsetLeft: left - parentOffsets.left,
          offsetTop: top - parentOffsets.top
        };
      }

      _runCommand(event) {
        let { command } = event.target.dataset;

        this.fire('command', { name: command });
      }

      _toggleLinkInput() {
        this.$['link-input'].hidden = !this.$['link-input'].hidden;
      }

      _checkToolIsActive(tool, activeTools) {
        return activeTools.indexOf(tool) !== -1;
      }
    }

    Polymer(SimplaTextToolbar)
  </script>
</dom-module>
