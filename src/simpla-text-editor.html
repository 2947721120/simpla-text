<link rel="import" href="../polymer/polymer.html">

<script>
  import Editor from './editor';
  import * as formatters from './editor/formatters';

  window.SimplaText = window.SimplaText || {};
  Object.assign(window.SimplaText, { Editor, formatters });
</script>

<dom-module id="simpla-text-toolbar">
  <template>
    <style>
      :host, *, *::before, *::after {
        box-sizing: border-box;
      }

      :host {
        -moz-osx-font-smoothing: grayscale;
         -webkit-font-smoothing: antialiased;
                 font-smoothing: antialiased;

        --tool-size: 25px;

        position: absolute;
        z-index: 9999;
        display: flex;
      }

      :host([hidden]) {
        display: none;
      }

      .tool {
        width: var(--tool-size);
        height: var(--tool-size);
        border: solid thin blue;
        flex-shrink: 0;
      }

      .tool[active] {
        border-bottom: 4px solid blue;
      }
    </style>
    <button
      class="tool"
      on-tap="_handleToolTap"
      active$="[[tools.bold.active]]"
      data-command="bold">b</button>
    <button
      class="tool"
      on-tap="_handleToolTap"
      active$="[[tools.italic.active]]"
      data-command="italic">i</button>
    <button
      class="tool"
      on-tap="_handleToolTap"
      active$="[[tools.underline.active]]"
      data-command="underline">u</button>
    <button
      class="tool"
      active$="[[_either(tools.link.active, _linkInputOpen)]]"
      on-tap="_toggleLinkInput"
      data-command="link">
      l
    </button>
    <span hidden$="[[!_linkInputOpen]]">
      <input id="_linkInput" type="text" on-keyup="_checkForExitKeys" value="{{_storedHref::input}}" />
    </span>
  </template>
  <script>
    const GUTTER = 5,
          INITIAL_TOOLS = () => ({
            bold: {
              active: false
            },

            italic: {
              active: false
            },

            underline: {
              active: false
            },

            link: {
              active: false,
              meta: {
                href: ''
              }
            }
          });

    function addPadding(rect, padding) {
      return {
        top: rect.top - padding,
        right: rect.right + padding,
        bottom: rect.bottom + padding,
        left: rect.left - padding,
        width: rect.width + 2 * padding,
        height: rect.height + 2 * padding
      };
    }

    class SimplaTextToolbar extends HTMLElement {
      beforeRegister() {
        this.is = 'simpla-text-toolbar';

        this.properties = {
          tools: {
            type: Object,
            value: INITIAL_TOOLS
          },

          target: {
            type: HTMLElement,
            value: null,
            observer: '_attachListenersToTarget'
          },

          range: {
            type: Object,
            value: null,
            observer: 'hoverOverRange'
          },

          hidden: {
            type: Boolean,
            reflectToAttribute: true
          },

          tabindex: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },

          _linkInputOpen: {
            type: Boolean,
            value: false,
            observer: '_linkInputOpenObserver'
          },

          _storedHref: {
            type: String,
            value: ''
          }
        };

        this.listeners = {
          'keyup': '_stopEvent',
          'keydown': '_stopEvent',
          'keypress': '_stopEvent',
          'focus': '_storeSelection'
        };
      }

      hoverOverRange(range) {
        let rangeBounds,
            ownBounds,
            boundaries,
            left,
            top;

        this.hidden = !range;
        if (!range) {
          return;
        }

        rangeBounds = addPadding(range.getBoundingClientRect(), GUTTER);
        ownBounds = this.getBoundingClientRect();

        boundaries = addPadding({
          top: 0,
          left: 0,
          right: window.innerWidth,
          bottom: window.innerHeight
        }, -GUTTER);

        ({ left, top } = this._getPositionsFromBounds({
          rangeBounds,
          ownBounds,
          boundaries
        }));

        // NOTE: HACK - This is doing a check: if the left and top will place is
        //  _relative_ to the parent element, then it should incorporate the
        //  parent's offsets from the viewport, otherwise it should just incorporate
        //  the scroll values (scroll values are already considered by parent
        //  in the truthy case). But this feels really fragile and should be fixed
        //  via CSS or something more solid.
        if (window.getComputedStyle(this.parentElement).position === 'relative') {
          let parentOffsets = this.parentElement.getBoundingClientRect();
          left -= parentOffsets.left;
          top -= parentOffsets.top;
        } else {
          left += window.scrollX;
          top += window.scrollY;
        }

        Object.assign(this.style, {
          left: `${left}px`,
          top: `${top}px`
        });
      }

      _getPositionsFromBounds({ ownBounds, rangeBounds, boundaries }) {
        let isOverRange = (dim) => dim > rangeBounds.top && dim < rangeBounds.bottom,
            centerOffset = (rangeBounds.width - ownBounds.width) / 2,
            left,
            top;

        // Move to center above range
        left = rangeBounds.left + centerOffset;
        top = rangeBounds.top - ownBounds.height;

        // Fit to within boundaries
        if (left < boundaries.left) {
          left = boundaries.left;
        }

        if (top < boundaries.top) {
          top = boundaries.top;
        }

        if (left + ownBounds.width > boundaries.right) {
          left = boundaries.right - ownBounds.width;
        }

        if (top + ownBounds.height > boundaries.bottom) {
          top = boundaries.bottom - ownBounds.height;
        }

        // Ensure it isn't covering the range
        if (isOverRange(top) || isOverRange(top + ownBounds.height)) {
          top = rangeBounds.bottom;
        }

        return { top, left };
      }

      _handleToolTap(event) {
        let { command } = event.target.dataset;

        this._runCommand(command);
      }

      _runCommand(command, options = {}) {
        if (this.target) {
          let currentState = this.target.state,
              transaction = currentState.tr.setSelection(this.__selection),
              newState = currentState.apply(transaction);

          this.target.dom.focus();
          this.target.view.updateState(newState);
          this.target.runCommand(command, options);
        }
      }

      _toggleLinkInput() {
        this._linkInputOpen = !this._linkInputOpen;
      }

      _either(a, b) {
        return a || b;
      }

      _stopEvent(event) {
        event.stopPropagation();
      }

      _checkForExitKeys(event) {
        const ENTER = 13,
              ESC = 27;

        if (event.keyCode === ENTER) {
          this._linkInputOpen = false;
        }

        if (event.keyCode === ESC) {
          event.target.value = this.get('tools.link.meta.href') || '';
          this._linkInputOpen = false;
        }
      }

      _linkInputOpenObserver(inputOpen) {
        let currentHref = this._storedHref && this._storedHref.trim();

        if (inputOpen) {
          this._storedHref = this.get('tools.link.meta.href') || '';
          this.$._linkInput.focus();
        } else {
          // HACK: This smells bad - it's active, so we're removing the link before
          //  reapplying it, I think it'll cause us problems, and regardless it
          //  just ain't clean
          if (this.get('tools.link.active')) {
            this._runCommand('link');
          }

          if (currentHref) {
            this._runCommand('link', { href: currentHref });
          }
        }
      }

      _storeSelection() {
        if (this.target) {
          this.__selection = this.target.state.selection;
        }
      }

      _attachListenersToTarget(target) {
        if (target) {
          target.dom.addEventListener('blur', (event) => {
            if (event.relatedTarget !== this) {
              this.hidden = true;
            }
          });
        }
      }
     }

    Polymer(SimplaTextToolbar)
  </script>
</dom-module>
